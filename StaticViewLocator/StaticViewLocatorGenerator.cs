using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace StaticViewLocator;

[Generator(LanguageNames.CSharp)]
public sealed class StaticViewLocatorGenerator : IIncrementalGenerator
{
    private const string StaticViewLocatorAttributeDisplayString = "StaticViewLocator.StaticViewLocatorAttribute";
    private const string ViewModelSuffix = "ViewModel";
    private const string ViewSuffix = "View";

    private const string AttributeText =
        """
        // <auto-generated />
        using System;

        namespace StaticViewLocator;

        [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
        public sealed class StaticViewLocatorAttribute : Attribute
        {
        }

        """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static ctx =>
            ctx.AddSource("StaticViewLocatorAttribute.cs", SourceText.From(AttributeText, Encoding.UTF8)));

        var viewModelsProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax classDeclaration &&
                                    classDeclaration.Identifier.ValueText.EndsWith(ViewModelSuffix, StringComparison.Ordinal),
                static (generatorContext, cancellationToken) =>
                {
                    var classDeclaration = (ClassDeclarationSyntax)generatorContext.Node;
                    if (generatorContext.SemanticModel.GetDeclaredSymbol(classDeclaration, cancellationToken) is not { } symbol)
                    {
                        return null;
                    }

                    return symbol.IsAbstract ? null : symbol;
                })
            .Where(static symbol => symbol is not null)
            .Select(static (symbol, _) => symbol!)
            .Collect();

        var locatorsProvider = context.SyntaxProvider.ForAttributeWithMetadataName(
            StaticViewLocatorAttributeDisplayString,
            static (node, _) => node is ClassDeclarationSyntax,
            static (attributeContext, _) => (INamedTypeSymbol)attributeContext.TargetSymbol);

        var inputs = locatorsProvider
            .Combine(context.CompilationProvider)
            .Combine(viewModelsProvider);

        context.RegisterSourceOutput(inputs, static (sourceProductionContext, tuple) =>
        {
            var ((locatorSymbol, compilation), viewModelSymbols) = tuple;

            var classSource = ProcessClass(compilation, locatorSymbol, viewModelSymbols);
            if (classSource is not null)
            {
                sourceProductionContext.AddSource(
                    $"{locatorSymbol.Name}_StaticViewLocator.cs",
                    SourceText.From(classSource, Encoding.UTF8));
            }
        });
    }

    private static string? ProcessClass(Compilation compilation, INamedTypeSymbol locatorSymbol, ImmutableArray<INamedTypeSymbol> viewModelSymbols)
    {
        if (!locatorSymbol.ContainingSymbol.Equals(locatorSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
        {
            return null;
        }

        var namespaceNameLocator = locatorSymbol.ContainingNamespace.ToDisplayString();

        var buildMethodExists = locatorSymbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Any(method => method.Name == "Build" && method.Parameters.Length == 1);

        var format = new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypes,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters |
                             SymbolDisplayGenericsOptions.IncludeTypeConstraints |
                             SymbolDisplayGenericsOptions.IncludeVariance);

        var classNameLocator = locatorSymbol.ToDisplayString(format);

        var relevantViewModels = new List<INamedTypeSymbol>();
        var seen = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

        foreach (var symbol in viewModelSymbols)
        {
            if (!symbol.Name.EndsWith(ViewModelSuffix, StringComparison.Ordinal) || symbol.IsAbstract)
            {
                continue;
            }

            if (seen.Add(symbol))
            {
                relevantViewModels.Add(symbol);
            }
        }

        relevantViewModels.Sort(static (left, right) =>
            string.Compare(left.ToDisplayString(), right.ToDisplayString(), StringComparison.Ordinal));

        var source = new StringBuilder(
            $$"""
            // <auto-generated />
            #nullable enable
            using System;
            using System.Collections.Generic;
            using Avalonia.Controls;

            namespace {{namespaceNameLocator}};

            public partial class {{classNameLocator}}
            {
            """);

        source.AppendLine();
        source.AppendLine("\tprivate static Dictionary<Type, Func<Control>> s_views = new()");
        source.AppendLine("\t{");

        var userControlViewSymbol = compilation.GetTypeByMetadataName("Avalonia.Controls.UserControl");
        var windowViewSymbol = compilation.GetTypeByMetadataName("Avalonia.Controls.Window");

        foreach (var viewModelSymbol in relevantViewModels)
        {
            var namespaceNameViewModel = viewModelSymbol.ContainingNamespace.ToDisplayString();
            var classNameViewModel = $"{namespaceNameViewModel}.{viewModelSymbol.ToDisplayString(format)}";
            var classNameView = classNameViewModel.Replace(ViewModelSuffix, ViewSuffix);

            var viewSymbol = compilation.GetTypeByMetadataName(classNameView);
            if (viewSymbol is null || (!viewSymbol.IsSubclassOf(userControlViewSymbol!)
                                       && !viewSymbol.IsSubclassOf(windowViewSymbol!)))
            {
                source.AppendLine(
                    $"\t\t[typeof({classNameViewModel})] = () => new TextBlock() {{ Text = \"Not Found: {classNameView}\" }},");
            }
            else
            {
                source.AppendLine($"\t\t[typeof({classNameViewModel})] = () => new {classNameView}(),");
            }
        }

        source.AppendLine("\t};");

        if (!buildMethodExists)
        {
            source.Append(
                """

	public Control? Build(object? data)
	{
		if (data is null)
		{
			return null;
		}

		var type = data.GetType();

		if (s_views.TryGetValue(type, out var func))
		{
			return func.Invoke();
		}

		throw new Exception($"Unable to create view for type: {type}");
	}

""");
        }

        source.AppendLine("}");

        return source.ToString();
    }
}

internal static class NamedTypeSymbolExtensions
{
    public static bool IsSubclassOf(this INamedTypeSymbol from, INamedTypeSymbol to)
    {
        if (from.BaseType != null)
        {
            return from.BaseType.Equals(to, SymbolEqualityComparer.Default) || IsSubclassOf(from.BaseType, to);
        }

        return false;
    }
}
