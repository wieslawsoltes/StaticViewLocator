using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

namespace StaticViewLocator;

[Generator(LanguageNames.CSharp)]
public sealed class StaticViewLocatorGenerator : IIncrementalGenerator
{
    private const string StaticViewLocatorAttributeDisplayString = "StaticViewLocator.StaticViewLocatorAttribute";
    private const string ViewModelSuffix = "ViewModel";
    private const string ViewSuffix = "View";
    private const string ViewModelNamespacePrefixesProperty = "build_property.StaticViewLocatorViewModelNamespacePrefixes";
    private const string IncludeInternalViewModelsProperty = "build_property.StaticViewLocatorIncludeInternalViewModels";
    private const string IncludeReferencedAssembliesProperty = "build_property.StaticViewLocatorIncludeReferencedAssemblies";
    private const string AdditionalViewBaseTypesProperty = "build_property.StaticViewLocatorAdditionalViewBaseTypes";

    private readonly struct GeneratorOptions
    {
        public GeneratorOptions(
            ImmutableArray<string> namespacePrefixes,
            bool includeInternalViewModels,
            bool includeReferencedAssemblies,
            ImmutableArray<string> additionalViewBaseTypes)
        {
            NamespacePrefixes = namespacePrefixes;
            IncludeInternalViewModels = includeInternalViewModels;
            IncludeReferencedAssemblies = includeReferencedAssemblies;
            AdditionalViewBaseTypes = additionalViewBaseTypes;
        }

        public ImmutableArray<string> NamespacePrefixes { get; }
        public bool IncludeInternalViewModels { get; }
        public bool IncludeReferencedAssemblies { get; }
        public ImmutableArray<string> AdditionalViewBaseTypes { get; }
    }

    private const string AttributeText =
        """
        // <auto-generated />
        using System;

        namespace StaticViewLocator;

        [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
        public sealed class StaticViewLocatorAttribute : Attribute
        {
        }

        """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static ctx =>
            ctx.AddSource("StaticViewLocatorAttribute.cs", SourceText.From(AttributeText, Encoding.UTF8)));

        var viewModelsProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax classDeclaration &&
                                    classDeclaration.Identifier.ValueText.EndsWith(ViewModelSuffix, StringComparison.Ordinal),
                static (generatorContext, cancellationToken) =>
                {
                    var classDeclaration = (ClassDeclarationSyntax)generatorContext.Node;
                    if (generatorContext.SemanticModel.GetDeclaredSymbol(classDeclaration, cancellationToken) is not { } symbol)
                    {
                        return null;
                    }

                    return symbol.IsAbstract ? null : symbol;
                })
            .Where(static symbol => symbol is not null)
            .Select(static (symbol, _) => symbol!)
            .Collect();

        var optionsProvider = context.AnalyzerConfigOptionsProvider
            .Select(static (options, _) => GetGeneratorOptions(options));

        var referencedViewModelsProvider = context.CompilationProvider
            .Combine(optionsProvider)
            .Select(static (pair, _) =>
                pair.Right.IncludeReferencedAssemblies
                    ? GetReferencedViewModels(pair.Left)
                    : ImmutableArray<INamedTypeSymbol>.Empty);

        var allViewModelsProvider = viewModelsProvider
            .Combine(referencedViewModelsProvider)
            .Select(static (pair, _) => pair.Left.AddRange(pair.Right));

        var locatorsProvider = context.SyntaxProvider.ForAttributeWithMetadataName(
            StaticViewLocatorAttributeDisplayString,
            static (node, _) => node is ClassDeclarationSyntax,
            static (attributeContext, _) => (INamedTypeSymbol)attributeContext.TargetSymbol);

        var inputs = locatorsProvider
            .Combine(context.CompilationProvider)
            .Combine(allViewModelsProvider)
            .Combine(optionsProvider);

        context.RegisterSourceOutput(inputs, static (sourceProductionContext, tuple) =>
        {
            var (((locatorSymbol, compilation), viewModelSymbols), options) = tuple;

            var classSource = ProcessClass(compilation, locatorSymbol, viewModelSymbols, options);
            if (classSource is not null)
            {
                sourceProductionContext.AddSource(
                    $"{locatorSymbol.Name}_StaticViewLocator.cs",
                    SourceText.From(classSource, Encoding.UTF8));
            }
        });
    }

    private static ImmutableArray<INamedTypeSymbol> GetReferencedViewModels(Compilation compilation)
    {
        var builder = ImmutableArray.CreateBuilder<INamedTypeSymbol>();

        foreach (var assembly in compilation.SourceModule.ReferencedAssemblySymbols)
        {
            CollectViewModels(assembly.GlobalNamespace, builder);
        }

        return builder.ToImmutable();
    }

    private static void CollectViewModels(INamespaceSymbol namespaceSymbol, ImmutableArray<INamedTypeSymbol>.Builder builder)
    {
        foreach (var type in namespaceSymbol.GetTypeMembers())
        {
            CollectViewModels(type, builder);
        }

        foreach (var child in namespaceSymbol.GetNamespaceMembers())
        {
            CollectViewModels(child, builder);
        }
    }

    private static void CollectViewModels(INamedTypeSymbol typeSymbol, ImmutableArray<INamedTypeSymbol>.Builder builder)
    {
        if (IsViewModelType(typeSymbol))
        {
            builder.Add(typeSymbol);
        }

        foreach (var nested in typeSymbol.GetTypeMembers())
        {
            CollectViewModels(nested, builder);
        }
    }

    private static GeneratorOptions GetGeneratorOptions(AnalyzerConfigOptionsProvider optionsProvider)
    {
        var namespacePrefixes = GetNamespacePrefixes(optionsProvider);
        var includeInternal = GetIncludeInternalViewModels(optionsProvider);
        var includeReferencedAssemblies = GetIncludeReferencedAssemblies(optionsProvider);
        var additionalViewBaseTypes = GetAdditionalViewBaseTypes(optionsProvider);

        return new GeneratorOptions(
            namespacePrefixes,
            includeInternal,
            includeReferencedAssemblies,
            additionalViewBaseTypes);
    }

    private static ImmutableArray<string> GetNamespacePrefixes(AnalyzerConfigOptionsProvider optionsProvider)
    {
        if (!optionsProvider.GlobalOptions.TryGetValue(ViewModelNamespacePrefixesProperty, out var rawValue))
        {
            return ImmutableArray<string>.Empty;
        }

        if (string.IsNullOrWhiteSpace(rawValue))
        {
            return ImmutableArray<string>.Empty;
        }

        var parts = rawValue.Split(new[] { ';', ',' }, StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length == 0)
        {
            return ImmutableArray<string>.Empty;
        }

        var builder = ImmutableArray.CreateBuilder<string>(parts.Length);
        foreach (var part in parts)
        {
            var trimmed = part.Trim();
            if (trimmed.Length > 0)
            {
                builder.Add(trimmed);
            }
        }

        return builder.ToImmutable();
    }

    private static bool GetIncludeInternalViewModels(AnalyzerConfigOptionsProvider optionsProvider)
    {
        if (!optionsProvider.GlobalOptions.TryGetValue(IncludeInternalViewModelsProperty, out var rawValue))
        {
            return false;
        }

        return bool.TryParse(rawValue, out var includeInternal) && includeInternal;
    }

    private static bool GetIncludeReferencedAssemblies(AnalyzerConfigOptionsProvider optionsProvider)
    {
        if (!optionsProvider.GlobalOptions.TryGetValue(IncludeReferencedAssembliesProperty, out var rawValue))
        {
            return false;
        }

        return bool.TryParse(rawValue, out var includeReferencedAssemblies) && includeReferencedAssemblies;
    }

    private static ImmutableArray<string> GetAdditionalViewBaseTypes(AnalyzerConfigOptionsProvider optionsProvider)
    {
        if (!optionsProvider.GlobalOptions.TryGetValue(AdditionalViewBaseTypesProperty, out var rawValue))
        {
            return ImmutableArray<string>.Empty;
        }

        if (string.IsNullOrWhiteSpace(rawValue))
        {
            return ImmutableArray<string>.Empty;
        }

        var parts = rawValue.Split(new[] { ';', ',' }, StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length == 0)
        {
            return ImmutableArray<string>.Empty;
        }

        var builder = ImmutableArray.CreateBuilder<string>(parts.Length);
        foreach (var part in parts)
        {
            var trimmed = part.Trim();
            if (trimmed.Length > 0)
            {
                builder.Add(trimmed);
            }
        }

        return builder.ToImmutable();
    }

    private static bool IsViewModelType(INamedTypeSymbol symbol)
    {
        if (symbol.TypeKind != TypeKind.Class || symbol.IsAbstract)
        {
            return false;
        }

        return symbol.Name.EndsWith(ViewModelSuffix, StringComparison.Ordinal);
    }

    private static bool IsViewModelCandidate(INamedTypeSymbol symbol, Compilation compilation, GeneratorOptions options)
    {
        if (!IsViewModelType(symbol))
        {
            return false;
        }

        if (!IsViewModelAccessible(symbol, compilation, options.IncludeInternalViewModels))
        {
            return false;
        }

        if (options.NamespacePrefixes.IsDefaultOrEmpty)
        {
            return true;
        }

        var namespaceName = symbol.ContainingNamespace.ToDisplayString();
        if (namespaceName.Length == 0)
        {
            return false;
        }

        return MatchesNamespace(namespaceName, options.NamespacePrefixes);
    }

    private static bool IsViewModelAccessible(
        INamedTypeSymbol symbol,
        Compilation compilation,
        bool includeInternal)
    {
        if (SymbolEqualityComparer.Default.Equals(symbol.ContainingAssembly, compilation.Assembly))
        {
            return true;
        }

        if (symbol.DeclaredAccessibility == Accessibility.Public && IsContainingTypesPublic(symbol))
        {
            return true;
        }

        if (!includeInternal || symbol.DeclaredAccessibility != Accessibility.Internal)
        {
            return false;
        }

        if (!IsContainingTypesAtMostInternal(symbol))
        {
            return false;
        }

        return symbol.ContainingAssembly.GivesAccessTo(compilation.Assembly);
    }

    private static bool IsContainingTypesPublic(INamedTypeSymbol symbol)
    {
        for (var containing = symbol.ContainingType; containing is not null; containing = containing.ContainingType)
        {
            if (containing.DeclaredAccessibility != Accessibility.Public)
            {
                return false;
            }
        }

        return true;
    }

    private static bool IsContainingTypesAtMostInternal(INamedTypeSymbol symbol)
    {
        for (var containing = symbol.ContainingType; containing is not null; containing = containing.ContainingType)
        {
            var accessibility = containing.DeclaredAccessibility;
            if (accessibility != Accessibility.Public && accessibility != Accessibility.Internal)
            {
                return false;
            }
        }

        return true;
    }

    private static bool MatchesNamespace(string namespaceName, ImmutableArray<string> namespacePrefixes)
    {
        foreach (var prefix in namespacePrefixes)
        {
            if (string.IsNullOrWhiteSpace(prefix))
            {
                continue;
            }

            var normalized = prefix.Trim();
            if (namespaceName.Equals(normalized, StringComparison.Ordinal) ||
                namespaceName.StartsWith(normalized + ".", StringComparison.Ordinal))
            {
                return true;
            }
        }

        return false;
    }

    private static string? ProcessClass(
        Compilation compilation,
        INamedTypeSymbol locatorSymbol,
        ImmutableArray<INamedTypeSymbol> viewModelSymbols,
        GeneratorOptions options)
    {
        if (!locatorSymbol.ContainingSymbol.Equals(locatorSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
        {
            return null;
        }

        var namespaceNameLocator = locatorSymbol.ContainingNamespace.ToDisplayString();

        var buildMethodExists = locatorSymbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Any(method => method.Name == "Build" && method.Parameters.Length == 1);

        var format = new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypes,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters |
                             SymbolDisplayGenericsOptions.IncludeTypeConstraints |
                             SymbolDisplayGenericsOptions.IncludeVariance);

        var classNameLocator = locatorSymbol.ToDisplayString(format);

        var relevantViewModels = new List<INamedTypeSymbol>();
        var seen = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

        foreach (var symbol in viewModelSymbols)
        {
            if (!IsViewModelCandidate(symbol, compilation, options))
            {
                continue;
            }

            if (seen.Add(symbol))
            {
                relevantViewModels.Add(symbol);
            }
        }

        relevantViewModels.Sort(static (left, right) =>
            string.Compare(left.ToDisplayString(), right.ToDisplayString(), StringComparison.Ordinal));

        var source = new StringBuilder(
            $$"""
            // <auto-generated />
            #nullable enable
            using System;
            using System.Collections.Generic;
            using Avalonia.Controls;

            namespace {{namespaceNameLocator}};

            public partial class {{classNameLocator}}
            {
            """);

        source.AppendLine();
        source.AppendLine("\tprivate static Dictionary<Type, Func<Control>> s_views = new()");
        source.AppendLine("\t{");

        var viewBaseTypes = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
        var userControlViewSymbol = compilation.GetTypeByMetadataName("Avalonia.Controls.UserControl");
        if (userControlViewSymbol is not null)
        {
            viewBaseTypes.Add(userControlViewSymbol);
        }

        var windowViewSymbol = compilation.GetTypeByMetadataName("Avalonia.Controls.Window");
        if (windowViewSymbol is not null)
        {
            viewBaseTypes.Add(windowViewSymbol);
        }

        foreach (var additionalTypeName in options.AdditionalViewBaseTypes)
        {
            var additionalSymbol = compilation.GetTypeByMetadataName(additionalTypeName);
            if (additionalSymbol is not null)
            {
                viewBaseTypes.Add(additionalSymbol);
            }
        }

        foreach (var viewModelSymbol in relevantViewModels)
        {
            var namespaceNameViewModel = viewModelSymbol.ContainingNamespace.ToDisplayString();
            var classNameViewModel = $"{namespaceNameViewModel}.{viewModelSymbol.ToDisplayString(format)}";
            var classNameView = classNameViewModel.Replace(ViewModelSuffix, ViewSuffix);

            var viewSymbol = compilation.GetTypeByMetadataName(classNameView);
            var isSupportedView = false;
            if (viewSymbol is not null && viewBaseTypes.Count > 0)
            {
                for (var current = viewSymbol; current is not null; current = current.BaseType)
                {
                    if (viewBaseTypes.Contains(current))
                    {
                        isSupportedView = true;
                        break;
                    }
                }
            }

            if (viewSymbol is null || !isSupportedView)
            {
                source.AppendLine(
                    $"\t\t[typeof({classNameViewModel})] = () => new TextBlock() {{ Text = \"Not Found: {classNameView}\" }},");
            }
            else
            {
                source.AppendLine($"\t\t[typeof({classNameViewModel})] = () => new {classNameView}(),");
            }
        }

        source.AppendLine("\t};");

        if (!buildMethodExists)
        {
            source.Append(
                """

	public Control? Build(object? data)
	{
		if (data is null)
		{
			return null;
		}

		var type = data.GetType();

		if (s_views.TryGetValue(type, out var func))
		{
			return func.Invoke();
		}

		throw new Exception($"Unable to create view for type: {type}");
	}

""");
        }

        source.AppendLine("}");

        return source.ToString();
    }
}
